<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DESAF√çO MEMORIA VIRTUAL - Sitio Interactivo</title>
<style>
  :root{
    --bg:#0f1720; --card:#0b1220; --muted:#9aa7b2; --accent:#2dd4bf; --accent2:#60a5fa; --text:#e6eef3;
    --danger:#ff7b7b; --ok:#7ee787;
    --glass: rgba(255,255,255,0.03);
    font-family: Inter, Roboto, "Segoe UI", Arial, sans-serif;
  }
  html,body{height:100%; margin:0; background:linear-gradient(180deg,#071028 0%, #071220 100%); color:var(--text);}
  /* Se modifica el .wrap para contener los dos bloques */
  .wrap{max-width:1200px;margin:24px auto;padding:20px;} 
  /* Estilo para el contenedor del Bloque 1 */
  .block-container{max-width:1200px;margin:24px auto;padding:20px;} 

  header{display:flex;gap:16px;align-items:center;margin-bottom:18px}
  h1{font-size:20px;margin:0}
  p.lead{margin:0;color:var(--muted);font-size:13px}

  .grid{display:grid;grid-template-columns:1fr 380px;gap:18px}
  .panel{background:var(--card);padding:14px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,0.45)}
  .small{font-size:13px;color:var(--muted)}
  .section-title{display:flex;align-items:center;gap:8px;margin-bottom:8px}
  .section-title h2{font-size:16px;margin:0}
  table{width:100%;border-collapse:collapse;font-size:13px}
  th,td{padding:8px;border-bottom:1px solid rgba(255,255,255,0.04);text-align:left}
  th{color:var(--accent2);font-weight:600}
  .badge{background:var(--glass);padding:4px 8px;border-radius:8px;font-size:12px;color:var(--muted)}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
  button, select, input[type="text"], input[type="number"]{background:#071422;border:1px solid rgba(255,255,255,0.03);color:var(--text);padding:8px 10px;border-radius:8px;cursor:pointer}
  button.primary{background:linear-gradient(90deg,var(--accent),var(--accent2));border:0;color:#022026}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;background:rgba(255,255,255,0.02);padding:6px;border-radius:6px}
  .row{display:flex;gap:12px;align-items:center}
  footer{margin-top:18px;font-size:12px;color:var(--muted);text-align:center}

  /* small visual components */
  .mem-visual{height:28px;border-radius:6px;overflow:hidden;background:#051018;border:1px solid rgba(255,255,255,0.03)}
  .block{height:100%;display:inline-block;vertical-align:top}

  /* === Men√∫ de navegaci√≥n === */
  nav{position:fixed;top:0;left:0;width:100%;background:#0b1220cc;backdrop-filter:blur(8px);z-index:999;
      display:flex;justify-content:space-between;align-items:center;padding:10px 20px;}
  nav .menu-links{display:flex;gap:18px;}
  nav a{color:var(--text);text-decoration:none;font-size:14px;}
  nav a:hover{color:var(--accent2);}
  .menu-btn{display:none;flex-direction:column;gap:4px;cursor:pointer;}
  .menu-btn div{width:22px;height:2px;background:var(--text);}
  
  /* Media Query: Aplica estilos solo en pantallas peque√±as (m√≥viles) */
  @media (max-width:980px){ .grid{grid-template-columns:1fr; } .panel{margin-bottom:12px} }

  @media (max-width:700px){
    /* OCULTA el men√∫ por defecto en m√≥vil */
    .menu-links{
      display:none; 
      flex-direction:column;gap:10px;position:absolute;top:50px;left:0;width:100%;
      background:#0b1220ee;padding:10px;
    }
    /* MUESTRA el men√∫ cuando tiene la clase 'active' */
    .menu-links.active{display:flex;}
    .menu-btn{display:flex;}
  }

  /* === QR === */
  .qr-container{text-align:center;margin-top:40px;}
  .qr-container img{width:150px;height:150px;}
</style>
</head>

<body>
<nav>
  <div class="menu-btn" onclick="document.getElementById('menuLinks').classList.toggle('active')">
    <div></div><div></div><div></div>
  </div>
  <div class="menu-links" id="menuLinks">
    <a href="#conceptos">Conceptos Fundamentales</a>
    <a href="#simulador-traduccion">Traducci√≥n de Direcciones</a>
    <a href="#algoritmos">Simulador de Reemplazo</a>
    <a href="#contenedores">Docker vs VM</a>
    <a href="#hipervisores">Hipervisores</a>
    <a href="#es">E/S y DMA</a>
    <a href="#overcommit-section">Overcommit</a>
  </div>
</nav>

<div class="block-container" style="margin-top:60px">
  <header>
    <div>
      <h1>DESAF√çO MEMORIA VIRTUAL - Sitio Web Interactivo üß†</h1>
      <p class="lead">BLOQUE 1: Conceptos y Pr√°ctica. Explora la gesti√≥n de memoria en SO: Paginaci√≥n, Segmentaci√≥n y Traducci√≥n de Direcciones.</p>
    </div>
    <div style="margin-left:auto">
      <span class="badge">Conceptos y Pr√°ctica</span>
    </div>
  </header>

  <main style="display:block; grid-template-columns:none; width:100%;">
    
    <section id="conceptos" class="panel">
      <div class="section-title"><h2>Conceptos Fundamentales de Gesti√≥n de Memoria</h2></div>
      
      <div style="margin-bottom: 15px;">
        <div style="font-weight: 600; color: var(--accent2);">1. Memoria Virtual</div>
        <p class="small">T√©cnica que permite a cada proceso operar como si tuviera acceso exclusivo a una gran memoria contigua (**espacio de direcciones l√≥gicas**). Facilita la multiprogramaci√≥n y el aislamiento.</p>
      </div>
      
      <div style="margin-bottom: 15px;">
        <div style="font-weight: 600; color: var(--accent2);">2. Tablas de P√°ginas (Paginaci√≥n)</div>
        <p class="small">Mecanismo que divide el espacio l√≥gico en **p√°ginas** y la RAM en **marcos (frames)**. La Tabla de P√°ginas mapea P√°gina $\rightarrow$ Marco. Es la base de SO como Windows/Linux. <span class="mono" style="display:block;margin-top:4px;">Direcci√≥n L√≥gica = N√∫mero de P√°gina + Offset</span></p>
      </div>

      <div style="margin-bottom: 15px;">
        <div style="font-weight: 600; color: var(--accent2);">3. Segmentaci√≥n y 4. Segmentaci√≥n Paginada</div>
        <p class="small">La **Segmentaci√≥n** divide la memoria en bloques de **tama√±o variable** por unidades l√≥gicas (c√≥digo, datos). La **Segmentaci√≥n Paginada** combina ambos para obtener protecci√≥n l√≥gica (segmentos) con gesti√≥n eficiente (p√°ginas).</p>
      </div>
      
      <hr style="border:0;border-top:1px solid rgba(255,255,255,0.05);margin:15px 0">
      
      <div class="section-title" style="margin-bottom: 4px;"><h3>Comparativa de Modelos de Administraci√≥n</h3></div>
      <table>
        <thead><tr><th>Modelo</th><th>Fragmentaci√≥n</th><th>Tama√±o</th><th>Ventaja</th></tr></thead>
        <tbody>
          <tr><td>Paginaci√≥n</td><td>Interna (peque√±a)</td><td>Fijo</td><td>F√°cil gesti√≥n y swapping</td></tr>
          <tr><td>Segmentaci√≥n Pag.</td><td>Interna (peque√±a)</td><td>Variable</td><td>Lo mejor de ambos: protecci√≥n y eficiencia</td></tr>
        </tbody>
      </table>
    </section>
    
    <section id="simulador-traduccion" class="panel" style="margin-top:12px">
      <div class="section-title"><h2>Simulador: Traducci√≥n L√≥gica $\rightarrow$ F√≠sica (Paginaci√≥n)</h2></div>
      <p class="small">Ingresa una Direcci√≥n L√≥gica y observa la traducci√≥n. Usamos 16 bits para la direcci√≥n l√≥gica y un tama√±o de p√°gina de 256 bytes (8 bits para offset).</p>

      <div class="controls">
        <label class="small">Direcci√≥n L√≥gica (decimal 0-65535):</label>
        <input type="number" id="logAddr" value="10500" style="width:120px;text-align:center;">
        <button class="primary" onclick="traducirDireccion()">Traducir</button>
      </div>

      <div id="traduccionResultado" class="mono" style="min-height:100px;margin-top:8px;padding:10px;background:rgba(255,255,255,0.02);color:var(--text);font-size:14px;">
        Esperando direcci√≥n l√≥gica...
      </div>
      
      <p class="small" style="margin-top:10px;">
        <strong>Par√°metros fijos:</strong> Tama√±o de p√°gina: 256 bytes. M√°ximo 256 marcos. 
      </p>
    </section>

    <section id="algoritmos" class="panel" style="margin-top:12px">
      <div class="section-title"><h2>Simulador: Algoritmos de Reemplazo de P√°ginas</h2></div>
      <p class="small">Visualiza c√≥mo FIFO y LRU manejan una secuencia de referencias con memoria limitada (marcos).</p>

      <div class="controls">
        <label class="small">Secuencia de Referencia (ej. 1,2,3,4,1,2,5,1):</label>
        <input type="text" id="refSeq" value="1, 2, 3, 4, 1, 2, 5, 1" style="width:250px;">
        <label class="small">Marcos (3-5):</label>
        <input type="number" id="frameCount" value="3" min="3" max="5" style="width:60px;text-align:center;">
        <button class="primary" onclick="simularReemplazo()">Simular</button>
      </div>
      <div id="simuladorOutput" class="mono" style="min-height:150px;margin-top:8px;padding:10px;background:rgba(255,255,255,0.02);overflow:auto;font-size:12px;">
        Resultados de simulaci√≥n (FIFO vs LRU) aparecer√°n aqu√≠.
      </div>
    </section>

  </main>
</div>


<div class="wrap"> 
  <header>
    <div>
      <h1>Categor√≠a 3: Investigaci√≥n y Profundizaci√≥n (Aplicaci√≥n en Tecnolog√≠as Modernas)‚Äî Conceptos de Sistemas Operativos</h1> 
      <p class="lead">Contenedores vs VM, paginaci√≥n en hipervisores, DMA y buffers, E/S, overcommit, y ejemplos de drivers. Explora con visualizaciones.</p>
    </div>
    <div style="margin-left:auto">
      <span class="badge">TP / Estudio</span>
    </div>
  </header>

  <div class="grid">
    <main>
      <section id="contenedores" class="panel">
        <div class="section-title"><h2>Contenedores vs M√°quinas Virtuales (memoria)</h2></div>
        <p class="small">Resumen corto: los <strong>contenedores</strong> comparten el kernel del host y usan la <em>memoria virtual del host</em>. Las m√°quinas virtuales (VMs) ejecutan su propio kernel y tienen su propia memoria virtual que debe ser mapeada al hardware f√≠sico por el hipervisor.</p>

        <div style="display:flex;gap:12px;margin-top:10px;flex-wrap:wrap">
          <div style="flex:1">
            <table>
              <thead><tr><th>Aspecto</th><th>Contenedores</th><th>VM (Hipervisor)</th></tr></thead>
              <tbody>
                <tr><td>Aislamiento</td><td>Procesos y namespaces (comparten kernel)</td><td>Kernel separado, aislamiento fuerte</td></tr>
                <tr><td>Memoria Virtual</td><td>Usan la VM del host (cgroups para l√≠mites)</td><td>VM tiene su propia VM; hipervisor traduce a RAM f√≠sica</td></tr>
                <tr><td>Overhead</td><td>Bajo</td><td>Alto (SO completo por VM)</td></tr>
                <tr><td>Casos uso</td><td>Microservicios, despliegues r√°pidos</td><td>Entornos heterog√©neos, aislamiento fuerte</td></tr>
              </tbody>
            </table>
          </div>

          <div style="width:320px">
            <div class="section-title"><h2>Simulador: Overcommit visual</h2></div>
            <div class="panel" style="padding:8px;background:rgba(255,255,255,0.02)">
              <label class="small">Memoria f√≠sica del host (MB)</label>
              <input id="hostMem" type="range" min="512" max="32768" value="8192" style="width:100%"/>
              <div class="row" style="justify-content:space-between"><small id="hostMemVal">8192 MB</small><small id="vmsVal">VMs: 3 √ó 4096</small></div>

              <label class="small" style="margin-top:8px">M√°quinas Virtuales (cantidad)</label>
              <input id="vmCount" type="range" min="1" max="8" value="2" style="width:100%"/>
              <div class="row" style="justify-content:space-between"><small id="vmCountVal">2 VMs</small><small id="overcommitVal">Overcommit ratio: 1.0</small></div>

              <button class="primary" style="margin-top:10px" onclick="updateOvercommit()">Actualizar</button>
              <p class="small" style="margin-top:8px">Este control estima el <em>overcommit ratio</em> si cada VM solicita X GB. Modific√° y observ√° riesgo de swap o OOM.</p>
            </div>
          </div>
        </div>
      </section>

      <section id="hipervisores" class="panel" style="margin-top:12px">
        <div class="section-title"><h2>Hipervisores ‚Äî traducci√≥n de direcciones (SPT vs EPT)</h2></div>
        <p class="small">En virtualizaci√≥n hay <strong>dos</strong> niveles de paginaci√≥n: la del SO invitado (guest) y la del hipervisor (host). Traducir la direcci√≥n l√≥gica del proceso invitado hasta la direcci√≥n f√≠sica real implica combinar o acelerar ambas traducciones.</p>
        <div style="display:flex;gap:12px;flex-wrap:wrap">
          <div style="flex:1">
            <table>
              <thead><tr><th>T√©cnica</th><th>Idea</th><th>Ventaja</th></tr></thead>
              <tbody>
                <tr><td>Shadow Page Tables</td><td>Hipervisor mantiene tablas que representan la composici√≥n de guest‚Üíhost</td><td>Funciona sin soporte HW, pero costoso</td></tr>
                <tr><td>Extended Page Tables (EPT)</td><td>Soporte de CPU para traducci√≥n anidada (Intel), evita mantener SPT</td><td>M√°s r√°pido y eficiente</td></tr>
              </tbody>
            </table>
          </div>
          <div style="width:320px">
            <div style="font-weight:600;margin-bottom:6px">Demostraci√≥n (animada)</div>
            <svg id="virtSVG" width="320" height="180" style="background:#041021;border-radius:8px"></svg>
            <div class="small" style="margin-top:6px">Pulsa <button onclick="runVirtAnim()">Animar traducci√≥n</button> para ver la ruta: l√≥gica (guest) $\rightarrow$ physGuest $\rightarrow$ physHost.</div>
          </div>
        </div>
      </section>

      <section id="es" class="panel" style="margin-top:12px">
        <div class="section-title"><h2>E/S: Programada (polling) vs Interrupciones</h2></div>
        <div style="display:flex;gap:12px">
          <div style="flex:1">
            <table>
              <thead><tr><th>Modo</th><th>C√≥mo</th><th>Pro/Contra</th></tr></thead>
              <tbody>
                <tr><td>E/S Programada</td><td>CPU consulta continuamente estado del dispositivo (polling)</td><td>Sencillo / Muy ineficiente (consume CPU)</td></tr>
                <tr><td>E/S por Interrupciones</td><td>Dispositivo solicita atenci√≥n (IRQ) cuando est√° listo</td><td>Eficiente / Requiere manejo de interrupciones</td></tr>
                <tr><td>DMA</td><td>Controlador DMA mueve bloques entre memoria y dispositivo</td><td>CPU libre, ideal para transferencias grandes</td></tr>
              </tbody>
            </table>
          </div>

          <div style="width:320px">
            <div style="font-weight:600;margin-bottom:6px">Simulador simple</div>
            <div class="small">Seleccion√° modo y pulsa <button onclick="simulateIO()">Simular 10 ticks</button></div>
            <select id="ioMode">
              <option value="poll">Polling</option>
              <option value="irq">Interrupciones</option>
              <option value="dma">DMA</option>
            </select>
            <div id="ioLog" class="mono" style="margin-top:8px;height:92px;overflow:auto;padding:8px;background:rgba(255,255,255,0.02)"></div>
          </div>
        </div>
      </section>

      <section id="buffers" class="panel" style="margin-top:12px">
        <div class="section-title"><h2>Buffers: simple, doble y circular</h2></div>
        <div style="display:flex;gap:12px;align-items:center">
          <div style="flex:1">
            <p class="small">Los buffers coordinan la velocidad entre productor/consumidor. El doble buffer permite solapamiento; el buffer circular permite flujo continuo con un √≠ndice de lectura/escritura.</p>
            <table>
              <thead><tr><th>Tipo</th><th>Descripci√≥n</th><th>Uso t√≠pico</th></tr></thead>
              <tbody>
                <tr><td>Simple</td><td>Un √∫nico buffer; alterna llenar/vaciar</td><td>Impresi√≥n secuencial</td></tr>
                <tr><td>Doble</td><td>Dos buffers alternados (ping-pong)</td><td>Transferencias con overlap (I/O/CPU)</td></tr>
                <tr><td>Circular</td><td>Multiples slots en anillo, √≠ndices r/w</td><td>Streaming de audio/video, redes</td></tr>
              </tbody>
            </table>
          </div>
          <div style="width:320px">
            <div style="font-weight:600;margin-bottom:6px">Animaci√≥n buffer circular</div>
            <svg id="ring" width="320" height="160" style="background:#04101a;border-radius:8px"></svg>
          </div>
        </div>
      </section>

      <section id="drivers" class="panel" style="margin-top:12px">
        <div class="section-title"><h2>Ejemplos reales de drivers (resumen)</h2></div>
        <ul class="small">
          <li><strong>Controlador de red (NIC)</strong> ‚Äî ej. <em>e1000</em> en Linux: manejo IRQ, rx/tx queues, DMA y zero-copy.</li>
          <li><strong>Drivers de bloque (discos, NVMe)</strong> ‚Äî reordenamiento de I/O, colas, uso intensivo de DMA.</li>
          <li><strong>Drivers de car√°cter (impresoras, serial)</strong> ‚Äî manejan <code>read/write/ioctl</code> y buffers en espacio kernel.</li>
          <li><strong>Drivers virtuales</strong> ‚Äî virtio (KVM) o controladores paravirtualizados para VM con mejor rendimiento.</li>
        </ul>
        <p class="small">Estos ejemplos se encuentran descritos y ejemplificados en libros como Tanenbaum, Stallings y Silberschatz y en documentaci√≥n de Linux (drivers/).</p>
      </section>

      <section id="overcommit-section" class="panel" style="margin-top:12px">
        <div class="section-title"><h2>Overcommit y riesgos operacionales</h2></div>
        <p class="small">Overcommit = asignar m√°s memoria virtual que memoria f√≠sica disponible, confiando en que no todo ser√° usado al mismo tiempo. Riesgos: swapping intenso, latencia alta, OOM (Out-Of-Memory).</p>
        <table>
          <thead><tr><th>Concepto</th><th>Memoria virtual</th><th>Overcommit</th></tr></thead>
          <tbody>
            <tr><td>Qu√© garantiza</td><td>Direcciones l√≥gicas respaldadas por swap/archivo</td><td>Ninguna garant√≠a f√≠sica inmediata; riesgo si demanda concurrente</td></tr>
            <tr><td>Riesgo</td><td>Swap (lento)</td><td>OOM y degradaci√≥n severa</td></tr>
            <tr><td>Manejo</td><td>Kernel + swap</td><td>Hipervisor: ballooning, compresi√≥n, limitaci√≥n (cgroups)</td></tr>
          </tbody>
        </table>
      </section>

    </main>

    <aside>
      <div class="panel" style="margin-bottom:12px">
        <div class="section-title"><h2>Atajos</h2></div>
        <div class="small">
          <p><strong>Animaciones</strong>: usa botones "Animar traducci√≥n" y "Simular I/O".</p>
          <p><strong>Exportar CSV / PNG</strong>: disponibles en la app ejemplo (simulador GUI).</p>
        </div>
      </div>

      <div class="panel" style="margin-bottom:12px">
        <div class="section-title"><h2>Comparativa breve</h2></div>
        <table>
          <thead><tr><th></th><th>Uso t√≠pico</th><th>Eficiencia</th></tr></thead>
          <tbody>
            <tr><td>Containers</td><td>Apps y microservicios</td><td>Alta</td></tr>
            <tr><td>VMs</td><td>Infraestructura completa</td><td>Media-baja</td></tr>
            <tr><td>Overcommit</td><td>Consolidaci√≥n</td><td>Riesgo si saturado</td></tr>
          </tbody>
        </table>
      </div>

      <div class="panel">
        <div class="section-title"><h2>Mini-simuladores</h2></div>

        <div style="margin-bottom:8px">
          <label class="small">Mostrar ejemplo de paginaci√≥n (frames)</label>
          <button onclick="drawFrames()">Ver frames</button>
          <div id="frames" class="mono" style="margin-top:8px;padding:8px;height:96px;overflow:auto;background:rgba(255,255,255,0.02)"></div>
        </div>

        <div>
          <label class="small">Mostrar buffer circular</label>
          <button onclick="ringAnim()">Animar ring</button>
        </div>
      </div>
    </aside>
  </div>

  <footer class="small">Hecho para estudio: contenedores vs VM, E/S (polling/IRQ/DMA), buffers, drivers reales, hipervisores y overcommit. Guarda este archivo para referencia offline.</footer>
  
  <div class="qr-container">
    <p>Escane√° este c√≥digo para abrir la p√°gina:</p>
    <img src="https://api.qrserver.com/v1/create-qr-code/?size=180x180&data=https://tu-pagina-ejemplo.com" alt="QR code">
  </div>

</div>


<script>
/* -------------------------
   Funciones de Interacci√≥n y Animaciones para AMBOS BLOQUES
   ------------------------- */

function q(id){return document.getElementById(id)}

/* -------------------------------------
   BLOQUE 1: TRADUCCI√ìN DE DIRECCIONES
   ------------------------------------- */
const PAGE_SIZE = 256; // 2^8
// Tabla de p√°ginas de ejemplo: {p√°gina_l√≥gica: marco_f√≠sico}
const PAGE_TABLE = {
  0: 3, 1: 1, 2: 8, 3: 2, 4: 5, 5: 10, 6: 4, 7: 7, 8: 6, 9: 0, 10: 9
};

function traducirDireccion(){
  const logAddrInput = q('logAddr').value;
  const logAddr = parseInt(logAddrInput);
  const output = q('traduccionResultado');
  
  if (isNaN(logAddr) || logAddr < 0 || logAddr > 65535) {
    output.innerHTML = `<span style="color:var(--danger);">Error: Direcci√≥n inv√°lida. Ingrese un n√∫mero entre 0 y 65535.</span>`;
    return;
  }
  
  const pageNumber = Math.floor(logAddr / PAGE_SIZE);
  const offset = logAddr % PAGE_SIZE;
  
  let resultHTML = `<div style="color:var(--accent2);font-weight:600;">Direcci√≥n L√≥gica: ${logAddr} (0x${logAddr.toString(16).toUpperCase()})</div>`;
  resultHTML += `<hr style="border:0;border-top:1px solid rgba(255,255,255,0.05);margin:6px 0;">`;
  
  resultHTML += `Paso 1: Calcular P√°gina y Offset:<br>`;
  resultHTML += `P√°gina (P) = ${logAddr} / ${PAGE_SIZE} = <strong>${pageNumber}</strong><br>`;
  resultHTML += `Offset (O) = ${logAddr} % ${PAGE_SIZE} = <strong>${offset}</strong><br><br>`;
  
  if (PAGE_TABLE[pageNumber] !== undefined) {
    const frameNumber = PAGE_TABLE[pageNumber];
    
    // Calcular Direcci√≥n F√≠sica
    const physAddr = (frameNumber * PAGE_SIZE) + offset;
    
    resultHTML += `Paso 2: Buscar en la Tabla de P√°ginas:<br>`;
    resultHTML += `P√°gina ${pageNumber} mapea al Marco (F): <strong>${frameNumber}</strong><br><br>`;
    
    resultHTML += `<div style="color:var(--accent);font-weight:600;">Direcci√≥n F√≠sica = (F * ${PAGE_SIZE}) + O</div>`;
    resultHTML += `<div style="color:var(--accent);font-weight:600;">Direcci√≥n F√≠sica = (${frameNumber} * ${PAGE_SIZE}) + ${offset} = <strong>${physAddr}</strong> (0x${physAddr.toString(16).toUpperCase()})</div>`;
    
  } else {
    resultHTML = `<div style="color:var(--danger);">¬°FALLO DE P√ÅGINA (PAGE FAULT)!</div>`;
    resultHTML += `La p√°gina l√≥gica ${pageNumber} no se encuentra cargada en la memoria f√≠sica.`;
  }
  
  output.innerHTML = resultHTML;
}

/* -------------------------------------
   BLOQUE 1: ALGORITMOS DE REEMPLAZO
   ------------------------------------- */

// Implementaci√≥n simple de FIFO
function simulateFIFO(sequence, frames) {
  const memory = [];
  let faults = 0;
  let nextToReplace = 0; // √çndice del marco m√°s antiguo
  
  for (const page of sequence) {
    let hit = memory.includes(page);
    if (!hit) {
      faults++;
      if (memory.length < frames) {
        memory.push(page);
      } else {
        memory[nextToReplace] = page;
        nextToReplace = (nextToReplace + 1) % frames;
      }
    }
  }
  return faults;
}

// Implementaci√≥n simple de LRU
function simulateLRU(sequence, frames) {
  const memory = [];
  let faults = 0;
  
  for (const page of sequence) {
    let index = memory.indexOf(page);
    if (index === -1) {
      faults++;
      if (memory.length < frames) {
        memory.push(page);
      } else {
        memory.shift(); // LRU: Elimina el elemento menos usado (el primero en el array)
        memory.push(page);
      }
    } else {
      // Hit: Mueve la p√°gina usada al final (m√°s reciente)
      memory.splice(index, 1);
      memory.push(page);
    }
  }
  return faults;
}

function simularReemplazo() {
  const seqStr = q('refSeq').value;
  const frames = parseInt(q('frameCount').value);
  const output = q('simuladorOutput');
  
  const sequence = seqStr.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
  
  if (sequence.length === 0 || frames < 3 || frames > 5) {
    output.innerHTML = `<span style="color:var(--danger);">Error: Secuencia inv√°lida o n√∫mero de marcos (3-5) incorrecto.</span>`;
    return;
  }
  
  const faultsFIFO = simulateFIFO(sequence, frames);
  const faultsLRU = simulateLRU(sequence, frames);

  let resultHTML = `<div style="color:var(--accent2);font-weight:600;">Secuencia: ${sequence.join(', ')} (${frames} Marcos)</div><br>`;
  
  resultHTML += `<div style="color:var(--accent);font-weight:600;">FIFO (First In, First Out)</div>`;
  resultHTML += `Fallos de P√°gina: <strong>${faultsFIFO}</strong> / ${sequence.length}<br><br>`;
  
  resultHTML += `<div style="color:var(--accent);font-weight:600;">LRU (Least Recently Used)</div>`;
  resultHTML += `Fallos de P√°gina: <strong>${faultsLRU}</strong> / ${sequence.length}<br><br>`;

  if (faultsLRU < faultsFIFO) {
    resultHTML += `<div style="color:var(--ok);">Conclusi√≥n: LRU (${faultsLRU} fallos) es M√ÅS eficiente que FIFO (${faultsFIFO} fallos) para esta secuencia.</div>`;
  } else if (faultsLRU === faultsFIFO) {
    resultHTML += `<div style="color:var(--muted);">Conclusi√≥n: Ambos algoritmos tuvieron el mismo rendimiento (${faultsLRU} fallos).</div>`;
  } else {
     resultHTML += `<div style="color:var(--danger);">Conclusi√≥n: FIFO (${faultsFIFO} fallos) es M√ÅS eficiente que LRU (${faultsLRU} fallos) para esta secuencia.</div>`;
  }

  output.innerHTML = resultHTML;
}


/* -------------------------------------
   BLOQUE 2: FUNCIONES DE INVESTIGACI√ìN
   ------------------------------------- */

/* Overcommit visual controls */
const host = q('hostMem'), vms = q('vmCount');
const hostVal = q('hostMemVal'), vmVal = q('vmCountVal'), ocVal = q('overcommitVal');
// Se necesita verificar si los elementos existen (solo en Bloque 2)
if (host && vms) {
    host.oninput = ()=> hostVal.textContent = host.value + ' MB';
    vms.oninput = ()=> vmVal.textContent = vms.value + ' VMs';
}

function updateOvercommit(){
  const hostMB = parseInt(host.value);
  const vmCount = parseInt(vms.value);
  const vmSizeMB = 4096; // ejemplo: cada VM pide 4GB
  const totalRequested = vmCount * vmSizeMB;
  const ratio = (totalRequested / hostMB).toFixed(2);
  ocVal.textContent = 'Overcommit ratio: ' + ratio;
  q('vmsVal').textContent = `VMs: ${vmCount} √ó ${vmSizeMB} MB`; // Actualiza el texto de las VMs
  
  // color feedback
  if(ratio <= 1) ocVal.style.color = '#7ee787';
  else if(ratio <= 2) ocVal.style.color = '#ffcf5c';
  else ocVal.style.color = '#ff7b7b';
}

/* Virtualization SVG animation: guest -> physGuest -> host phys */
function runVirtAnim(){
  const svg = q('virtSVG');
  svg.innerHTML = '';
  const w = svg.clientWidth, h = svg.clientHeight;
  // draw 3 boxes
  function rect(x,y,label,color){
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
    r.setAttribute('x',x); r.setAttribute('y',y); r.setAttribute('width',120); r.setAttribute('height',36);
    r.setAttribute('fill',color); r.setAttribute('rx',6);
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('x', x+60); t.setAttribute('y', y+22); t.setAttribute('text-anchor','middle');
    t.setAttribute('fill','#0b1220'); t.setAttribute('font-size',12); t.textContent = label;
    g.appendChild(r); g.appendChild(t); svg.appendChild(g);
    return g;
  }
  const g1 = rect(12,20,'Logical addr (Guest)','#60a5fa');
  const g2 = rect(140,20,'Guest phys (pseudo)','#2dd4bf');
  const g3 = rect(268,20,'Host phys (real)','#f59e0b');
  // arrows
  function arrow(x1,y1,x2,y2){
    const l = document.createElementNS('http://www.w3.org/2000/svg','line');
    l.setAttribute('x1',x1); l.setAttribute('y1',y1); l.setAttribute('x2',x2); l.setAttribute('y2',y2);
    l.setAttribute('stroke','#9aa7b2'); l.setAttribute('stroke-width',2); svg.appendChild(l);
  }
  arrow(132,38,140,38); arrow(260,38,268,38);
  // animate dot path
  let t=0;
  const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');
  dot.setAttribute('r',6); dot.setAttribute('fill','#fff'); svg.appendChild(dot);
  function step(){
    t++;
    if(t<40){ dot.setAttribute('cx', 60 + t*1.8); dot.setAttribute('cy', 38); }
    else if(t<80){ dot.setAttribute('cx', 188 + (t-40)*1.8); dot.setAttribute('cy', 38); }
    else{ dot.setAttribute('cx', 316); dot.setAttribute('cy', 38); }
    if(t<120) requestAnimationFrame(step);
  }
  step();
}

/* I/O simulation (poll vs irq vs dma) */
function simulateIO(){
  const mode = q('ioMode').value;
  const log = q('ioLog');
  log.textContent = '';
  // simple parameters
  const deviceReadyAt = Math.floor(Math.random()*6)+2;
  log.textContent += `device will be ready at tick ${deviceReadyAt}\n`;
  for(let tick=0;tick<10;tick++){
    if(mode==='poll'){
      log.textContent += `tick ${tick}: CPU polls -> `;
      if(tick===deviceReadyAt) log.textContent += 'device ready -> handle data\n'; else log.textContent += 'not ready\n';
    } else if(mode==='irq'){
      log.textContent += `tick ${tick}: CPU does work\n`;
      if(tick===deviceReadyAt) log.textContent += `  device raises IRQ -> CPU handles interrupt\n`;
    } else { // DMA
      log.textContent += `tick ${tick}: DMA transfers in background\n`;
      if(tick===deviceReadyAt) log.textContent += `  DMA reports completion -> CPU notified\n`;
    }
  }
}

/* Buffer circular animation */
function drawRing(){
  const svg = q('ring');
  svg.innerHTML = '';
  const w = svg.clientWidth, h = svg.clientHeight;
  const cx = w/2, cy = h/2, r = Math.min(w,h)/2 - 20;
  const slots = 8;
  for(let i=0;i<slots;i++){
    const angle = (i/slots)*Math.PI*2 - Math.PI/2;
    const x = cx + Math.cos(angle)*r;
    const y = cy + Math.sin(angle)*r;
    const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circ.setAttribute('cx',x); circ.setAttribute('cy',y); circ.setAttribute('r',16);
    circ.setAttribute('fill','#0b1220'); circ.setAttribute('stroke','#1f6f8b'); svg.appendChild(circ);
  }
}
function ringAnim(){
  drawRing();
  const svg = q('ring');
  const w = svg.clientWidth, h = svg.clientHeight;
  const cx = w/2, cy = h/2, r = Math.min(w,h)/2 - 20;
  const slots = 8;
  let producer = 0, consumer = 4;
  const dots = [];
  for(let i=0;i<slots;i++){
    const angle = (i/slots)*Math.PI*2 - Math.PI/2;
    const x = cx + Math.cos(angle)*r;
    const y = cy + Math.sin(angle)*r;
    const d = document.createElementNS('http://www.w3.org/2000/svg','circle');
    d.setAttribute('cx',x); d.setAttribute('cy',y); d.setAttribute('r',8);
    d.setAttribute('fill','#072b2a'); svg.appendChild(d); dots.push(d);
  }
  let step=0;
  function tick(){
    // producer writes
    dots[producer].setAttribute('fill','#2a9d8f');
    // consumer reads previous slot
    if(step>1){ dots[consumer].setAttribute('fill','#041018'); consumer=(consumer+1)%slots; }
    producer=(producer+1)%slots;
    step++;
    if(step<32) setTimeout(tick,350);
  }
  tick();
}

/* Frames view (sidebar) */
function drawFrames(){
  const out = q('frames'); out.textContent = '';
  const frames = 12;
  const occupied = Math.floor(Math.random()*frames);
  for(let i=0;i<frames;i++){
    if(i<occupied) out.textContent += `[F${i}: used] `; else out.textContent += `[F${i}: free] `;
  }
}

/* Inicializaci√≥n */
document.addEventListener('DOMContentLoaded', ()=>{
  // Solo ejecuta si los elementos existen (Bloque 2)
  if(q('hostMem') && q('ring') && q('virtSVG')) {
    updateOvercommit();
    drawRing();
    runVirtAnim();
  }
  
  // Cierre del men√∫ hamburguesa (CORREGIDO)
  const menuLinks = document.querySelectorAll('.menu-links a');
  const menuContainer = q('menuLinks'); // Usamos el ID agregado
  
  // 1. JS para cerrar el men√∫ en m√≥vil al hacer clic en un enlace
  menuLinks.forEach(link => {
    link.addEventListener('click', () => {
      // Ocultar el men√∫ al hacer clic (solo si est√° visible)
      if (menuContainer.classList.contains('active')) {
        menuContainer.classList.remove('active');
      }
    });
  });
});
</script>
</body>
</html>
