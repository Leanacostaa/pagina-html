<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Resumen Interactivo - Conceptos de Sistemas Operativos</title>
<style>
  :root{
    --bg:#0f1720; --card:#0b1220; --muted:#9aa7b2; --accent:#2dd4bf; --accent2:#60a5fa; --text:#e6eef3;
    --danger:#ff7b7b; --ok:#7ee787;
    --glass: rgba(255,255,255,0.03);
    font-family: Inter, Roboto, "Segoe UI", Arial, sans-serif;
  }
  html,body{height:100%; margin:0; background:linear-gradient(180deg,#071028 0%, #071220 100%); color:var(--text);}
  .wrap{max-width:1200px;margin:24px auto;padding:20px;}
  header{display:flex;gap:16px;align-items:center;margin-bottom:18px}
  h1{font-size:20px;margin:0}
  p.lead{margin:0;color:var(--muted);font-size:13px}

  .grid{display:grid;grid-template-columns:1fr 380px;gap:18px}
  .panel{background:var(--card);padding:14px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,0.45)}
  .small{font-size:13px;color:var(--muted)}
  .section-title{display:flex;align-items:center;gap:8px;margin-bottom:8px}
  .section-title h2{font-size:16px;margin:0}
  table{width:100%;border-collapse:collapse;font-size:13px}
  th,td{padding:8px;border-bottom:1px solid rgba(255,255,255,0.04);text-align:left}
  th{color:var(--accent2);font-weight:600}
  .badge{background:var(--glass);padding:4px 8px;border-radius:8px;font-size:12px;color:var(--muted)}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
  button, select{background:#071422;border:1px solid rgba(255,255,255,0.03);color:var(--text);padding:8px 10px;border-radius:8px;cursor:pointer}
  button.primary{background:linear-gradient(90deg,var(--accent),var(--accent2));border:0;color:#022026}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;background:rgba(255,255,255,0.02);padding:6px;border-radius:6px}
  .row{display:flex;gap:12px;align-items:center}
  footer{margin-top:18px;font-size:12px;color:var(--muted);text-align:center}

  /* small visual components */
  .mem-visual{height:28px;border-radius:6px;overflow:hidden;background:#051018;border:1px solid rgba(255,255,255,0.03)}
  .block{height:100%;display:inline-block;vertical-align:top}

  /* === Menú de navegación === */
  nav{position:fixed;top:0;left:0;width:100%;background:#0b1220cc;backdrop-filter:blur(8px);z-index:999;
      display:flex;justify-content:space-between;align-items:center;padding:10px 20px;}
  nav .menu-links{display:flex;gap:18px;}
  nav a{color:var(--text);text-decoration:none;font-size:14px;}
  nav a:hover{color:var(--accent2);}
  .menu-btn{display:none;flex-direction:column;gap:4px;cursor:pointer;}
  .menu-btn div{width:22px;height:2px;background:var(--text);}
  
  /* Media Query: Aplica estilos solo en pantallas pequeñas (móviles) */
  @media (max-width:980px){ .grid{grid-template-columns:1fr; } .panel{margin-bottom:12px} }

  @media (max-width:700px){
    /* OCULTA el menú por defecto en móvil */
    .menu-links{
      display:none; 
      flex-direction:column;gap:10px;position:absolute;top:50px;left:0;width:100%;
      background:#0b1220ee;padding:10px;
    }
    /* MUESTRA el menú cuando tiene la clase 'active' */
    .menu-links.active{display:flex;}
    .menu-btn{display:flex;}
  }

  /* === QR === */
  .qr-container{text-align:center;margin-top:40px;}
  .qr-container img{width:150px;height:150px;}
</style>
</head>

<body>
<nav>
  <div class="menu-btn" onclick="document.querySelector('.menu-links').classList.toggle('active')">
    <div></div><div></div><div></div>
  </div>
  <div class="menu-links">
    <a href="#contenedores">Contenedores vs VM</a>
    <a href="#hipervisores">Hipervisores</a>
    <a href="#es">E/S</a>
    <a href="#buffers">Buffers</a>
    <a href="#drivers">Drivers</a>
    <a href="#overcommit-section">Overcommit</a>
  </div>
</nav>

<div class="wrap" style="margin-top:60px">
  <header>
    <div>
      <h1>Resumen interactivo — Conceptos de Sistemas Operativos</h1>
      <p class="lead">Contenedores vs VM, paginación en hipervisores, DMA y buffers, E/S, overcommit, y ejemplos de drivers. Explora con visualizaciones.</p>
    </div>
    <div style="margin-left:auto">
      <span class="badge">TP / Estudio</span>
    </div>
  </header>

  <div class="grid">
    <main>
      <section id="contenedores" class="panel">
        <div class="section-title"><h2>Contenedores vs Máquinas Virtuales (memoria)</h2></div>
        <p class="small">Resumen corto: los <strong>contenedores</strong> comparten el kernel del host y usan la <em>memoria virtual del host</em>. Las máquinas virtuales (VMs) ejecutan su propio kernel y tienen su propia memoria virtual que debe ser mapeada al hardware físico por el hipervisor.</p>

        <div style="display:flex;gap:12px;margin-top:10px;flex-wrap:wrap">
          <div style="flex:1">
            <table>
              <thead><tr><th>Aspecto</th><th>Contenedores</th><th>VM (Hipervisor)</th></tr></thead>
              <tbody>
                <tr><td>Aislamiento</td><td>Procesos y namespaces (comparten kernel)</td><td>Kernel separado, aislamiento fuerte</td></tr>
                <tr><td>Memoria Virtual</td><td>Usan la VM del host (cgroups para límites)</td><td>VM tiene su propia VM; hipervisor traduce a RAM física</td></tr>
                <tr><td>Overhead</td><td>Bajo</td><td>Alto (SO completo por VM)</td></tr>
                <tr><td>Casos uso</td><td>Microservicios, despliegues rápidos</td><td>Entornos heterogéneos, aislamiento fuerte</td></tr>
              </tbody>
            </table>
          </div>

          <div style="width:320px">
            <div class="section-title"><h2>Simulador: Overcommit visual</h2></div>
            <div class="panel" style="padding:8px;background:rgba(255,255,255,0.02)">
              <label class="small">Memoria física del host (MB)</label>
              <input id="hostMem" type="range" min="512" max="32768" value="8192" style="width:100%"/>
              <div class="row" style="justify-content:space-between"><small id="hostMemVal">8192 MB</small><small id="vmsVal">VMs: 3 × 4096</small></div>

              <label class="small" style="margin-top:8px">Máquinas Virtuales (cantidad)</label>
              <input id="vmCount" type="range" min="1" max="8" value="2" style="width:100%"/>
              <div class="row" style="justify-content:space-between"><small id="vmCountVal">2 VMs</small><small id="overcommitVal">Overcommit ratio: 1.0</small></div>

              <button class="primary" style="margin-top:10px" onclick="updateOvercommit()">Actualizar</button>
              <p class="small" style="margin-top:8px">Este control estima el <em>overcommit ratio</em> si cada VM solicita X GB. Modificá y observá riesgo de swap o OOM.</p>
            </div>
          </div>
        </div>
      </section>

      <section id="hipervisores" class="panel" style="margin-top:12px">
        <div class="section-title"><h2>Hipervisores — traducción de direcciones (SPT vs EPT)</h2></div>
        <p class="small">En virtualización hay <strong>dos</strong> niveles de paginación: la del SO invitado (guest) y la del hipervisor (host). Traducir la dirección lógica del proceso invitado hasta la dirección física real implica combinar o acelerar ambas traducciones.</p>
        <div style="display:flex;gap:12px;flex-wrap:wrap">
          <div style="flex:1">
            <table>
              <thead><tr><th>Técnica</th><th>Idea</th><th>Ventaja</th></tr></thead>
              <tbody>
                <tr><td>Shadow Page Tables</td><td>Hipervisor mantiene tablas que representan la composición de guest→host</td><td>Funciona sin soporte HW, pero costoso</td></tr>
                <tr><td>Extended Page Tables (EPT)</td><td>Soporte de CPU para traducción anidada (Intel), evita mantener SPT</td><td>Más rápido y eficiente</td></tr>
              </tbody>
            </table>
          </div>
          <div style="width:320px">
            <div style="font-weight:600;margin-bottom:6px">Demostración (animada)</div>
            <svg id="virtSVG" width="320" height="180" style="background:#041021;border-radius:8px"></svg>
            <div class="small" style="margin-top:6px">Pulsa <button onclick="runVirtAnim()">Animar traducción</button> para ver la ruta: lógica (guest) → physGuest → physHost.</div>
          </div>
        </div>
      </section>

      <section id="es" class="panel" style="margin-top:12px">
        <div class="section-title"><h2>E/S: Programada (polling) vs Interrupciones</h2></div>
        <div style="display:flex;gap:12px">
          <div style="flex:1">
            <table>
              <thead><tr><th>Modo</th><th>Cómo</th><th>Pro/Contra</th></tr></thead>
              <tbody>
                <tr><td>E/S Programada</td><td>CPU consulta continuamente estado del dispositivo (polling)</td><td>Sencillo / Muy ineficiente (consume CPU)</td></tr>
                <tr><td>E/S por Interrupciones</td><td>Dispositivo solicita atención (IRQ) cuando está listo</td><td>Eficiente / Requiere manejo de interrupciones</td></tr>
                <tr><td>DMA</td><td>Controlador DMA mueve bloques entre memoria y dispositivo</td><td>CPU libre, ideal para transferencias grandes</td></tr>
              </tbody>
            </table>
          </div>

          <div style="width:320px">
            <div style="font-weight:600;margin-bottom:6px">Simulador simple</div>
            <div class="small">Seleccioná modo y pulsa <button onclick="simulateIO()">Simular 10 ticks</button></div>
            <select id="ioMode">
              <option value="poll">Polling</option>
              <option value="irq">Interrupciones</option>
              <option value="dma">DMA</option>
            </select>
            <div id="ioLog" class="mono" style="margin-top:8px;height:92px;overflow:auto;padding:8px;background:rgba(255,255,255,0.02)"></div>
          </div>
        </div>
      </section>

      <section id="buffers" class="panel" style="margin-top:12px">
        <div class="section-title"><h2>Buffers: simple, doble y circular</h2></div>
        <div style="display:flex;gap:12px;align-items:center">
          <div style="flex:1">
            <p class="small">Los buffers coordinan la velocidad entre productor/consumidor. El doble buffer permite solapamiento; el buffer circular permite flujo continuo con un índice de lectura/escritura.</p>
            <table>
              <thead><tr><th>Tipo</th><th>Descripción</th><th>Uso típico</th></tr></thead>
              <tbody>
                <tr><td>Simple</td><td>Un único buffer; alterna llenar/vaciar</td><td>Impresión secuencial</td></tr>
                <tr><td>Doble</td><td>Dos buffers alternados (ping-pong)</td><td>Transferencias con overlap (I/O/CPU)</td></tr>
                <tr><td>Circular</td><td>Multiples slots en anillo, índices r/w</td><td>Streaming de audio/video, redes</td></tr>
              </tbody>
            </table>
          </div>
          <div style="width:320px">
            <div style="font-weight:600;margin-bottom:6px">Animación buffer circular</div>
            <svg id="ring" width="320" height="160" style="background:#04101a;border-radius:8px"></svg>
          </div>
        </div>
      </section>

      <section id="drivers" class="panel" style="margin-top:12px">
        <div class="section-title"><h2>Ejemplos reales de drivers (resumen)</h2></div>
        <ul class="small">
          <li><strong>Controlador de red (NIC)</strong> — ej. <em>e1000</em> en Linux: manejo IRQ, rx/tx queues, DMA y zero-copy.</li>
          <li><strong>Drivers de bloque (discos, NVMe)</strong> — reordenamiento de I/O, colas, uso intensivo de DMA.</li>
          <li><strong>Drivers de carácter (impresoras, serial)</strong> — manejan <code>read/write/ioctl</code> y buffers en espacio kernel.</li>
          <li><strong>Drivers virtuales</strong> — virtio (KVM) o controladores paravirtualizados para VM con mejor rendimiento.</li>
        </ul>
        <p class="small">Estos ejemplos se encuentran descritos y ejemplificados en libros como Tanenbaum, Stallings y Silberschatz y en documentación de Linux (drivers/).</p>
      </section>

      <section id="overcommit-section" class="panel" style="margin-top:12px">
        <div class="section-title"><h2>Overcommit y riesgos operacionales</h2></div>
        <p class="small">Overcommit = asignar más memoria virtual que memoria física disponible, confiando en que no todo será usado al mismo tiempo. Riesgos: swapping intenso, latencia alta, OOM (Out-Of-Memory).</p>
        <table>
          <thead><tr><th>Concepto</th><th>Memoria virtual</th><th>Overcommit</th></tr></thead>
          <tbody>
            <tr><td>Qué garantiza</td><td>Direcciones lógicas respaldadas por swap/archivo</td><td>Ninguna garantía física inmediata; riesgo si demanda concurrente</td></tr>
            <tr><td>Riesgo</td><td>Swap (lento)</td><td>OOM y degradación severa</td></tr>
            <tr><td>Manejo</td><td>Kernel + swap</td><td>Hipervisor: ballooning, compresión, limitación (cgroups)</td></tr>
          </tbody>
        </table>
      </section>

    </main>

    <aside>
      <div class="panel" style="margin-bottom:12px">
        <div class="section-title"><h2>Atajos</h2></div>
        <div class="small">
          <p><strong>Animaciones</strong>: usa botones "Animar traducción" y "Simular I/O".</p>
          <p><strong>Exportar CSV / PNG</strong>: disponibles en la app ejemplo (simulador GUI).</p>
        </div>
      </div>

      <div class="panel" style="margin-bottom:12px">
        <div class="section-title"><h2>Comparativa breve</h2></div>
        <table>
          <thead><tr><th></th><th>Uso típico</th><th>Eficiencia</th></tr></thead>
          <tbody>
            <tr><td>Containers</td><td>Apps y microservicios</td><td>Alta</td></tr>
            <tr><td>VMs</td><td>Infraestructura completa</td><td>Media-baja</td></tr>
            <tr><td>Overcommit</td><td>Consolidación</td><td>Riesgo si saturado</td></tr>
          </tbody>
        </table>
      </div>

      <div class="panel">
        <div class="section-title"><h2>Mini-simuladores</h2></div>

        <div style="margin-bottom:8px">
          <label class="small">Mostrar ejemplo de paginación (frames)</label>
          <button onclick="drawFrames()">Ver frames</button>
          <div id="frames" class="mono" style="margin-top:8px;padding:8px;height:96px;overflow:auto;background:rgba(255,255,255,0.02)"></div>
        </div>

        <div>
          <label class="small">Mostrar buffer circular</label>
          <button onclick="ringAnim()">Animar ring</button>
        </div>
      </div>
    </aside>
  </div>

  <footer class="small">Hecho para estudio: contenedores vs VM, E/S (polling/IRQ/DMA), buffers, drivers reales, hipervisores y overcommit. Guarda este archivo para referencia offline.</footer>
  
  <div class="qr-container">
    <p>Escaneá este código para abrir la página:</p>
    <img src="https://api.qrserver.com/v1/create-qr-code/?size=180x180&data=https://tu-pagina-ejemplo.com" alt="QR code">
  </div>

</div>


<script>
/* -------------------------
   Interacciones y animaciones
   ------------------------- */

function q(id){return document.getElementById(id)}

/* Overcommit visual controls */
const host = q('hostMem'), vms = q('vmCount');
const hostVal = q('hostMemVal'), vmVal = q('vmCountVal'), ocVal = q('overcommitVal');
host.oninput = ()=> hostVal.textContent = host.value + ' MB';
vms.oninput = ()=> vmVal.textContent = vms.value + ' VMs';
function updateOvercommit(){
  const hostMB = parseInt(host.value);
  const vmCount = parseInt(vms.value);
  const vmSizeMB = 4096; // ejemplo: cada VM pide 4GB
  const totalRequested = vmCount * vmSizeMB;
  const ratio = (totalRequested / hostMB).toFixed(2);
  ocVal.textContent = 'Overcommit ratio: ' + ratio;
  // color feedback
  if(ratio <= 1) ocVal.style.color = '#7ee787';
  else if(ratio <= 2) ocVal.style.color = '#ffcf5c';
  else ocVal.style.color = '#ff7b7b';
}

/* Virtualization SVG animation: guest -> physGuest -> host phys */
function runVirtAnim(){
  const svg = q('virtSVG');
  svg.innerHTML = '';
  const w = svg.clientWidth, h = svg.clientHeight;
  // draw 3 boxes
  function rect(x,y,label,color){
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
    r.setAttribute('x',x); r.setAttribute('y',y); r.setAttribute('width',120); r.setAttribute('height',36);
    r.setAttribute('fill',color); r.setAttribute('rx',6);
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('x', x+60); t.setAttribute('y', y+22); t.setAttribute('text-anchor','middle');
    t.setAttribute('fill','#0b1220'); t.setAttribute('font-size',12); t.textContent = label;
    g.appendChild(r); g.appendChild(t); svg.appendChild(g);
    return g;
  }
  const g1 = rect(12,20,'Logical addr (Guest)','#60a5fa');
  const g2 = rect(140,20,'Guest phys (pseudo)','#2dd4bf');
  const g3 = rect(268,20,'Host phys (real)','#f59e0b');
  // arrows
  function arrow(x1,y1,x2,y2){
    const l = document.createElementNS('http://www.w3.org/2000/svg','line');
    l.setAttribute('x1',x1); l.setAttribute('y1',y1); l.setAttribute('x2',x2); l.setAttribute('y2',y2);
    l.setAttribute('stroke','#9aa7b2'); l.setAttribute('stroke-width',2); svg.appendChild(l);
  }
  arrow(132,38,140,38); arrow(260,38,268,38);
  // animate dot path
  let t=0;
  const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');
  dot.setAttribute('r',6); dot.setAttribute('fill','#fff'); svg.appendChild(dot);
  function step(){
    t++;
    if(t<40){ dot.setAttribute('cx', 60 + t*1.8); dot.setAttribute('cy', 38); }
    else if(t<80){ dot.setAttribute('cx', 188 + (t-40)*1.8); dot.setAttribute('cy', 38); }
    else{ dot.setAttribute('cx', 316); dot.setAttribute('cy', 38); }
    if(t<120) requestAnimationFrame(step);
  }
  step();
}

/* I/O simulation (poll vs irq vs dma) */
function simulateIO(){
  const mode = q('ioMode').value;
  const log = q('ioLog');
  log.textContent = '';
  // simple parameters
  const deviceReadyAt = Math.floor(Math.random()*6)+2;
  log.textContent += `device will be ready at tick ${deviceReadyAt}\n`;
  for(let tick=0;tick<10;tick++){
    if(mode==='poll'){
      log.textContent += `tick ${tick}: CPU polls -> `;
      if(tick===deviceReadyAt) log.textContent += 'device ready -> handle data\n'; else log.textContent += 'not ready\n';
    } else if(mode==='irq'){
      log.textContent += `tick ${tick}: CPU does work\n`;
      if(tick===deviceReadyAt) log.textContent += `  device raises IRQ -> CPU handles interrupt\n`;
    } else { // DMA
      log.textContent += `tick ${tick}: DMA transfers in background\n`;
      if(tick===deviceReadyAt) log.textContent += `  DMA reports completion -> CPU notified\n`;
    }
  }
}

/* Buffer circular animation */
function drawRing(){
  const svg = q('ring');
  svg.innerHTML = '';
  const w = svg.clientWidth, h = svg.clientHeight;
  const cx = w/2, cy = h/2, r = Math.min(w,h)/2 - 20;
  const slots = 8;
  for(let i=0;i<slots;i++){
    const angle = (i/slots)*Math.PI*2 - Math.PI/2;
    const x = cx + Math.cos(angle)*r;
    const y = cy + Math.sin(angle)*r;
    const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
    circ.setAttribute('cx',x); circ.setAttribute('cy',y); circ.setAttribute('r',16);
    circ.setAttribute('fill','#0b1220'); circ.setAttribute('stroke','#1f6f8b'); svg.appendChild(circ);
  }
}
function ringAnim(){
  drawRing();
  const svg = q('ring');
  const w = svg.clientWidth, h = svg.clientHeight;
  const cx = w/2, cy = h/2, r = Math.min(w,h)/2 - 20;
  const slots = 8;
  let producer = 0, consumer = 4;
  const dots = [];
  for(let i=0;i<slots;i++){
    const angle = (i/slots)*Math.PI*2 - Math.PI/2;
    const x = cx + Math.cos(angle)*r;
    const y = cy + Math.sin(angle)*r;
    const d = document.createElementNS('http://www.w3.org/2000/svg','circle');
    d.setAttribute('cx',x); d.setAttribute('cy',y); d.setAttribute('r',8);
    d.setAttribute('fill','#072b2a'); svg.appendChild(d); dots.push(d);
  }
  let step=0;
  function tick(){
    // producer writes
    dots[producer].setAttribute('fill','#2a9d8f');
    // consumer reads previous slot
    if(step>1){ dots[consumer].setAttribute('fill','#041018'); consumer=(consumer+1)%slots; }
    producer=(producer+1)%slots;
    step++;
    if(step<32) setTimeout(tick,350);
  }
  tick();
}

/* Frames view (sidebar) */
function drawFrames(){
  const out = q('frames'); out.textContent = '';
  const frames = 12;
  const occupied = Math.floor(Math.random()*frames);
  for(let i=0;i<frames;i++){
    if(i<occupied) out.textContent += `[F${i}: used] `; else out.textContent += `[F${i}: free] `;
  }
}

/* JS para cerrar el menú en móvil al hacer clic en un enlace */
document.addEventListener('DOMContentLoaded', ()=>{
  updateOvercommit();
  drawRing();
  
  // 1. Obtener todos los enlaces del menú
  const menuLinks = document.querySelectorAll('.menu-links a');
  const menuContainer = document.querySelector('.menu-links');

  // 2. Añadir un evento de clic a cada enlace
  menuLinks.forEach(link => {
    link.addEventListener('click', () => {
      // 3. Ocultar el menú al hacer clic (solo si está visible)
      if (menuContainer.classList.contains('active')) {
        menuContainer.classList.remove('active');
      }
    });
  });
});
</script>
</body>
</html>
